package main

import (
	f "fmt"
)

/*

	一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。
使用一个指针引用一个值被称为间接引用。
	Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。
	在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用

prt 定义为一个指针类型，标识指向存储int类型值的指针，prt本身是一个内存地址值，所以需要通过内存地址值进行赋值
	（通过&a 可以获取到变量a所在内存的地址）可以通过 *ptr 获取指针指向内存地址存储的变量值（我们通常将这种引用称作「间接引用」
	Go 语言之所以引入指针类型，主要基于两点考虑，一个是为程序员提供操作变量对应内存数据结构的能力；
		另一个是为了提高程序的性能（指针可以直接指向某个变量值的内存地址，可以极大节省内存空间，操作效率也更高），
		这在系统编程、操作系统或者网络应用中是不容忽视的因素
	符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；这被称为反引用（或者内容或者间接引用）操作符；
	另一种说法是指针转移

*/

func main0() {
	a := 100
	/*声明指针类型*/
	var prt *int
	/*初始化指针类型值为变量 a*/
	prt = &a
	f.Println(prt)
	f.Println(*prt)

	/*当一个指针被定义后没有分配到任何变量时，它的值为 nil。*/
	var prt1 *string
	f.Println(prt1)
	v := 20
	ptr := &v
	f.Println(*ptr)

	ptr1 := &prt1
	f.Println(ptr1)

}

func main3() {
	var i int
	f.Println("----------i变量--------------")
	f.Printf("i的数据类型= %T\ni的初始值为= %v\ni的内存地址= %v\n", i, i, &i)
	f.Println("----------ptr变量---------------")
	var ptr *int
	f.Printf("ptr的数据类型= %T\nptr的初始值为= %v\nptr的内存地址= %v\n", ptr, ptr, &ptr)

	f.Println("----------ptr引用i的地址--------")
	ptr = &i
	f.Printf("i的内存地址名称= %v\nptr的内存地址名称= %v\n", &i, &ptr)
	f.Printf("ptr中存储的是i变量的地址名称:\n &i= %v\nptr= %v\n", &i, ptr)
	f.Println("--------总结-----------")
	f.Printf("所以关系是 ptr: %v == &i: %v\n", ptr, &i)

}

var (
	a int
	b int
	c *int
)

/*通过init函数来初始化*/
func init() {
	a = 10
	b = 10
}
func main() {

	/*通过获取指针指向地址值来修改原值*/

	age := 20

	var Newage *int //定义指针类型变量 Newage
	Newage = &age   // 把age的内存地址赋值给指针类型变量Newage
	*Newage = 40    // 通过获取
	f.Printf("*Newage的地址值为：%v,Newage的地址为：%v\n", &Newage, Newage)
	f.Printf("age的地址为: %v\n,age的地址值为: %v\n", &age, age)

	/*计算a+b的和*/

}
